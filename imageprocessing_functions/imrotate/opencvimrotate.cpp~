#include <numeric>
#include "opencv2/core/core.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/opencv.hpp"
#include <iostream>
using namespace cv;
using namespace std;
extern "C"
{
#include "api_scilab.h"
#include "Scierror.h"
#include "BOOL.h"
#include <localization.h>
int opencvimrotate(char *fname, unsigned long fname_len)
{
 // Error management variable
        SciErr sciErr;
    //variable info
	int iRows		= 0;
	int iCols		= 0;
        int piRows		= 0;
	int piCols		= 0;
	int* piAddr1		= NULL;
        int* piAddr2            = NULL;
	int* piLen		= NULL;
	double* pstData	        = NULL;
        int* pstData2    	= NULL;
         //checking input argument
       CheckInputArgument(pvApiCtx, 2, 2);
       CheckOutputArgument(pvApiCtx, 1, 1)         
//for first argument
        sciErr = getVarAddressFromPosition(pvApiCtx,1,&piAddr1);
        if (sciErr.iErr)
        {
        printError(&sciErr, 0);
        return 0;
        }
        sciErr = getMatrixOfInteger32(pvApiCtx, piAddr1, &piRows, &piCols,&pstData2);
	if(sciErr.iErr)
	{
		printError(&sciErr, 0);
		return 0;
	}    
       Mat img(465,700,CV_8UC3); 
        int k=0;
        for(int i = 0;i < 465;i++){
        for(int j = 0;j < 700;j++){
        img.at<cv::Vec3b>(i,j)[2]= pstData2[k];k++; 
        img.at<cv::Vec3b>(i,j)[1]= pstData2[k];k++;
        img.at<cv::Vec3b>(i,j)[0]= pstData2[k];k++;  
            }
        }
      
       //for second argument
        sciErr = getVarAddressFromPosition(pvApiCtx,2,&piAddr2);
        if (sciErr.iErr)
        {
        printError(&sciErr, 0);
        return 0;
        }
        sciErr = getMatrixOfDouble(pvApiCtx, piAddr2, &iRows, &iCols ,&pstData);
        if(sciErr.iErr)
	{
		printError(&sciErr, 0);
		return 0;
	}       
        //variables are passed now pass to matrix to functions
        Mat dst;
        Point2f pt((img.cols)/2., (img.rows)/2.);    
        Mat r = getRotationMatrix2D(pt, pstData[0], 1.0);
        warpAffine(img, dst, r, Size(img.cols, img.rows));
//       namedWindow( "dst", CV_WINDOW_AUTOSIZE );
//     imshow("dst",dst);
//   waitKey(0); //wait infinite time for a keypress
// destroyWindow("dst"); 
         int *n = NULL;
         n = (int*)malloc(sizeof(int) *dst.rows *dst.cols *3);
        // int i,j,k=0,r,b,g;
         k=0;
         //int k=0;
        for(int i = 0;i < dst.rows;i++){
   cv::Vec3b* pixel = dst.ptr<cv::Vec3b>(i);
    for(int j = 0;j < dst.cols;j++){
           n[k] = pixel[j][2];k++;
           n[k]= pixel[j][1];k++;
           n[k]= pixel[j][0];k++;
            }
        }
 //SciErr createMatrixOfInteger32(void* _pvCtx, int _iVar, int _iRows, int _iCols, const int* _piData32)
    sciErr = createMatrixOfInteger32(pvApiCtx, nbInputArgument(pvApiCtx) + 1,1,3*dst.rows*dst.cols, n);
    free(n); // Data have been copied into Scilab memory
    if (sciErr.iErr)
    {
//Make sure everything is cleanup in case of error
        printError(&sciErr, 0);
        return 0;
    }
AssignOutputVariable(pvApiCtx, 1) = nbInputArgument(pvApiCtx) + 1;
ReturnArguments(pvApiCtx);
         return 0;
}
}
